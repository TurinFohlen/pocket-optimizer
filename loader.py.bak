#!/usr/bin/env python3
"""
全库引入者·智能版 —— 自动扫描并导入所有组件模块。
"""

import os
import sys
import importlib.util
from pathlib import Path

# 要扫描的顶层包名列表
PACKAGES = [
    'sources',
    'algorithms',
    'uis',
    'exporters',
    'processors',
    'analyzers',
    'services',
]

def import_module_from_file(py_file: Path, package_name: str, rel_path: Path):
    """动态导入单个 .py 文件作为模块"""
    # 将相对路径转换为模块点号分隔名
    sub_module = ".".join(rel_path.with_suffix('').parts)
    module_name = f"{package_name}.{sub_module}"
    
    spec = importlib.util.spec_from_file_location(module_name, py_file)
    if spec and spec.loader:
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)
        sys.modules[module_name] = module
        return True
    return False

def scan_and_import():
    """扫描所有指定包目录，导入每个 .py 文件（非 __init__）"""
    root_dir = Path(__file__).parent
    imported = [] # 存储 (depth, module_name)
    
    for pkg in PACKAGES:
        pkg_dir = root_dir / pkg
        if not pkg_dir.exists():
            continue
        
        # 递归扫描
        for py_file in pkg_dir.rglob("*.py"):
            if py_file.name == "__init__.py":
                continue
            try:
                # 获取相对于当前包（pkg）的路径
                rel_path = py_file.relative_to(pkg_dir)
                # 计算深度：顶层为 0，每进一级目录 +1
                depth = len(rel_path.parts) - 1
                
                if import_module_from_file(py_file, pkg, rel_path):
                    mod_full_name = f"{pkg}.{'.'.join(rel_path.with_suffix('').parts)}"
                    imported.append((depth, mod_full_name))
            except Exception as e:
                print(f"⚠️ 导入失败 {py_file.name}: {e}")
    
    return imported

# ========== 执行自动扫描导入 ==========
loaded_modules = scan_and_import()
print(f"✅ 全库智能加载完成，已注册 {len(loaded_modules)} 个组件")

# 1. 强制排序，确保父模块在子模块上面
sorted_mods = sorted(loaded_modules, key=lambda x: x[1])

for _, mod_name in sorted_mods:
    # 2. 核心逻辑：根据模块名中的点号数量计算深度
    # 例如: 'uis.cli_menu' -> 1个点 -> 深度为 0
    # 例如: 'services.data.adapter' -> 2个点 -> 深度为 1
    dots_count = mod_name.count('.')
    real_depth = dots_count - 1
    
    # 3. 严格执行 8 空格缩进 + 装饰符
    # 使用 \t 可能在不同终端表现不一，所以直接用空字符串
    indent_space = "        " * real_depth
    print(f"{indent_space}└── {mod_name}")
