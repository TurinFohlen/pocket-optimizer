# uis/legacy_menu.py - è‡ªåŠ¨æå–å¹¶ç¼©è¿›åçš„å®Œæ•´ä»£ç 
# å·²ç¡®ä¿ç¼©è¿›æ­£ç¡®ï¼Œå¤åˆ¶ç²˜è´´å³å¯ä½¿ç”¨

from registry import registry
from orchestrator import Orchestrator, OptimizationConfig, HistoryEntry
import numpy as np
import time
import os
import re

# å¯¼å…¥æ‰€éœ€çš„æœåŠ¡ï¼ˆç¿»è¯‘å™¨ã€è·ç¦»ç­‰ï¼‰
def _get_translator_json():
    cls = registry.get_component('service.translator.json')
    return cls() if cls else None

def _get_translator_wl():
    cls = registry.get_component('service.translator.wl')
    return cls() if cls else None

@registry.register(
    name='ui.legacy_menu',   
    type_='ui',
    signature='run()'
)
class LegacyOptimizationProgram:
    """
    ä»æ—§ç³»ç»Ÿç§»æ¤çš„äº¤äº’ç•Œé¢ï¼Œå®Œå…¨ä¿ç•™åŸæ±åŸå‘³çš„ç”¨æˆ·ä½“éªŒï¼Œ
    ä½†å†…éƒ¨å·²é€‚é…æ–°æ¶æ„ï¼šä½¿ç”¨ Orchestratorã€ç¿»è¯‘å™¨æœåŠ¡ã€å¯¼å‡ºå™¨ç»„ä»¶ã€‚
    """
    def __init__(self):
        self.optimizer = None   
        self.config = None
        self.selected_algorithm = None
#    
    def run(self):
    """ä¸»å…¥å£ - å®Œå…¨æ²¿ç”¨åŸ run() çš„é€»è¾‘"""
    
        print("\n" + "=" * 80)               # âœ… Empty line + separator
        print(" å¢å¼ºé€šç”¨ä¼˜åŒ–ç³»ç»Ÿ Â· ç»å…¸ç•Œé¢ï¼ˆå·²é€‚é…æ–°å¼•æ“ï¼‰")  # âœ… Title
        print("=" * 80)                                  # âœ… Separator
    
        self.configure()   
        
        # åˆ›å»º Orchestratorï¼ˆæ›¿ä»£æ—§ optimizerï¼‰
        source_name = 'source.test_function'   
        orch = Orchestrator(self.config, source_name=source_name)
        
        # ç®—æ³•é€‰æ‹©ï¼ˆå·²åœ¨ configure ä¸­è®¾ç½® self.selected_algorithmï¼‰
        algo_name = self._map_algorithm_name(self.selected_algorithm)
        if not algo_name:
            print("âŒ æœªé€‰æ‹©æœ‰æ•ˆç®—æ³•")
            return
        
        # å¯¼å…¥å†å²æ•°æ®ï¼ˆå¤ç”¨æ—§æ–¹æ³•ï¼Œå†…éƒ¨è°ƒç”¨ç¿»è¯‘å™¨æœåŠ¡ï¼‰
        self.import_historical_data(orch)
        
        # æ‰§è¡Œä¼˜åŒ–
        print(f"
ğŸš€ æ­£åœ¨è¿è¡Œ {algo_name} ...")
        best_point, best_value = orch.run(algo_name)
        
        # æ˜¾ç¤ºç»“æœ
        print(f"
âœ… æœ€ä¼˜è§£: {best_point}")
        print(f"âœ… æœ€ä¼˜å€¼: {best_value:.6f}")
        
        # å¯¼å‡ºç»“æœ
        self._export_results(orch)
    
    def configure(self):
        """å®Œå…¨å¤ç”¨åŸ configure()ï¼Œä»…å°† self.optimizer ç›¸å…³å»é™¤"""
        print("
 ä¼˜åŒ–ç¨‹åºé…ç½®")
        print("="*50)
        n_dims = int(input("è¯·è¾“å…¥å‚æ•°æ•°é‡ (é»˜è®¤2): ") or 2)
        param_names = []
        param_bounds = []
        for i in range(n_dims):
            print(f"
å‚æ•° {i+1}:")
            name = input(f"  å‚æ•°åç§° (é»˜è®¤: å‚æ•°{i+1}): ") or f"å‚æ•°{i+1}"
            param_names.append(name)
            min_val = float(input(f"  æœ€å°å€¼ (é»˜è®¤: 0): ") or 0)
            max_val = float(input(f"  æœ€å¤§å€¼ (é»˜è®¤: 100): ") or 100)
            param_bounds.append((min_val, max_val))
        num_samples = int(input(f"
æ¯ç‚¹é‡‡æ ·æ¬¡æ•° (é»˜è®¤5): ") or 5)
        precision = int(input(f"ç²¾åº¦æˆªæ–­å°æ•°ä½æ•° (é»˜è®¤2): ") or 2)
        max_evaluations = int(input(f"æœ€å¤§è¯„ä¼°æ¬¡æ•° (é»˜è®¤30): ") or 30)
        
        # ç®—æ³•é€‰æ‹©èœå•ï¼ˆåŸæ ·ï¼‰
        print(f"
ä½¿ç”¨é«˜çº§ç®—æ³•?")
        print("A. å…¨æµç¨‹ä¼˜åŒ– (è‡ªåŠ¨åˆ‡æ¢å¤šç§ç®—æ³•)")
        print("B. æ‹‰ä¸æ–¹é‡‡æ · (Latin Hypercube)")
        print("C. é—ä¼ è¿›åŒ–æ³• (Genetic Algorithm)")
        print("D. å…±è½­æ–¹å‘æ³• (Powell)")
        print("E. ç²’å­ç¾¤ç®—æ³• (Particle Swarm)")
        print("F. æ¨¡æ‹Ÿé€€ç«æ³• (Simulated Annealing)")
        print("G. è´å¶æ–¯ä¼˜åŒ– (Bayesian Optimization)")
        algo_choice = input("
è¯·é€‰æ‹© (A/B/C/D/E/F/G, é»˜è®¤A): ").strip().upper() or 'A'
        
        algo_map = {
            'A': None,  
            'B': 'latin_hypercube',
            'C': 'genetic',
            'D': 'powell',
            'E': 'particle_swarm',
            'F': 'simulated_annealing',
            'G': 'bayesian_ei'
        }
        self.selected_algorithm = algo_map.get(algo_choice, None)
        
        # æ„å»ºé…ç½®å¯¹è±¡
        self.config = OptimizationConfig(
            param_bounds=param_bounds,
            param_names=param_names,
            num_samples=num_samples,
            max_evaluations=max_evaluations
        )
        self._display_config()
    
    def _display_config(self):
        """åŸæ ·å¤åˆ¶"""
        if self.config is None:
            print(" é…ç½®æœªè®¾ç½®")
            return
        print("
 å½“å‰é…ç½®:")
        print(f"   å‚æ•°ç»´åº¦: {len(self.config.param_names)}")
        for name, bounds in zip(self.config.param_names, self.config.param_bounds):
            print(f"     {name}: [{bounds[0]}, {bounds[1]}]")
        print(f"   æ¯ç‚¹é‡‡æ ·æ¬¡æ•°: {self.config.num_samples}")
        print(f"   æœ€å¤§è¯„ä¼°æ¬¡æ•°: {self.config.max_evaluations}")
    
    def _map_algorithm_name(self, algo_code):
        """å°†æ—§ç®—æ³•ä»£å·æ˜ å°„ä¸ºæ–°æ¶æ„çš„æ³¨å†Œå"""
        if algo_code is None:
            return 'algorithm.genetic'
        mapping = {
            'genetic': 'algorithm.genetic',
            'powell': 'algorithm.powell',
            'particle_swarm': 'algorithm.pso',
            'simulated_annealing': 'algorithm.simulated_annealing',
            'bayesian_ei': 'algorithm.bayesian',
            'latin_hypercube': 'algorithm.latin_hypercube'
        }
        return mapping.get(algo_code, 'algorithm.genetic')
    
    def import_historical_data(self, orch):
        """å¤ç”¨æ—§äº¤äº’é€»è¾‘"""
        print("
 å†å²æ•°æ®å¯¼å…¥")
        print("="*60)
        print("
 é€‰æ‹©å¯¼å…¥æ–¹å¼:")
        print("  A.  Wolfram Language (.wl) æ–‡ä»¶å¯¼å…¥")
        print("  B.  JSONæ–‡ä»¶æ‰¹é‡å¯¼å…¥ (æ¨èï¼Œé€‚åˆ10+æ¡æ•°æ®)")
        print("  C. âŒ¨  æ‰‹åŠ¨é€æ¡è¾“å…¥ (é€‚åˆå°‘é‡æ•°æ®ï¼Œ1-5æ¡)")
        print("  D. â­  è·³è¿‡å¯¼å…¥ (done)")
        choice = input("
è¯·é€‰æ‹© (A/B/C/D, é»˜è®¤D): ").strip().upper()
        if choice == '' or choice == 'D':
            print("â­  è·³è¿‡å†å²æ•°æ®å¯¼å…¥")
            return
        elif choice == 'A':
            self._import_from_wl(orch)
        elif choice == 'B':
            self._import_from_json(orch)
        elif choice == 'C':
            self._import_manually(orch)
        else:
            print(" æ— æ•ˆé€‰æ‹©ï¼Œè·³è¿‡å¯¼å…¥")
    
    def _import_from_json(self, orch):
        """è°ƒç”¨ service.translator.json æœåŠ¡"""
        svc_cls = registry.get_component('service.translator.json')
        if not svc_cls:
            print("âŒ JSONç¿»è¯‘å™¨æœåŠ¡æœªæ³¨å†Œ")
            return
        translator = svc_cls()
        
        default_filename = "optimization_history.json"
        filename = input(f"
 JSONæ–‡ä»¶åæˆ–è·¯å¾„ (é»˜è®¤: {default_filename}): ").strip() or default_filename
        found_path = self._find_file(filename, ['.json'])
        if found_path is None:
            print(f"
 æ— æ³•æ‰¾åˆ°æ–‡ä»¶ '{filename}'")
            self._show_search_paths(filename)
            return
        
        try:
            data = translator.from_file(found_path)
            print(f"âœ… æˆåŠŸè§£æ JSON æ–‡ä»¶ï¼Œæ‰¾åˆ° {len(data) if isinstance(data, list) else 1} æ¡è®°å½•")
            if isinstance(data, list):
                for record in data:
                    self._import_single_record(record, orch)
            else:
                self._import_single_record(data, orch)
        except Exception as e:
            print(f"âŒ JSON å¯¼å…¥å¤±è´¥: {e}")
    
    def _import_from_wl(self, orch):
        """è°ƒç”¨ service.translator.wl æœåŠ¡"""
        svc_cls = registry.get_component('service.translator.wl')
        if not svc_cls:
            print("âŒ Wolframç¿»è¯‘å™¨æœåŠ¡æœªæ³¨å†Œ")
            return
        translator = svc_cls()
        
        default_filename = "optimization_history.wl"
        filename = input(f"
 WLæ–‡ä»¶åæˆ–è·¯å¾„ (é»˜è®¤: {default_filename}): ").strip() or default_filename
        found_path = self._find_file(filename, ['.wl', '.m', '.nb'])
        if found_path is None:
            print(f"
 æ— æ³•æ‰¾åˆ°æ–‡ä»¶ '{filename}'")
            self._show_search_paths(filename)
            return
        
        with open(found_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        lines = content.split('
')
        imported = 0
        for line in lines:
            line = line.strip()
            if not line or ('->' not in line and '{' not in line):
                continue
            py_code = translator.wl_to_python(line)
            if py_code:
                try:
                    value = eval(py_code)
                    record = {
                        'point': [0]*len(self.config.param_names),
                        'value': value,
                        'algorithm_used': 'wl_import'
                    }
                    self._import_single_record(record, orch)
                    imported += 1
                except:
                    pass
        print(f"âœ… å·²å¯¼å…¥ {imported} æ¡ WL è®°å½•")
    
    def _import_manually(self, orch):
        """æ‰‹åŠ¨é€æ¡è¾“å…¥"""
        print("
âŒ¨  æ‰‹åŠ¨é€æ¡è¾“å…¥")
        print("-"*60)
        print(f"
 éœ€è¦ {len(self.config.param_bounds)} ä¸ªå‚æ•°å€¼ + 1ä¸ªæµ‹é‡å€¼")
        imported_count = 0
        while True:
            prompt = f"è®°å½• {imported_count + 1} (done=å®Œæˆ): "
            line = input(prompt).strip()
            if line.lower() in ['done', ''] and imported_count > 0:
                break
            try:
                point, value = self._parse_manual_input(line)
                entry = HistoryEntry(
                    point=point,
                    value=value,
                    algorithm='manual',
                    timestamp=time.time()
                )
                orch.history.append(entry)
                imported_count += 1
                print(f"   è®°å½• {imported_count} å·²æ·»åŠ ")
            except Exception as e:
                print(f"   è¾“å…¥æ ¼å¼é”™è¯¯: {e}")
        print(f"
 æ‰‹åŠ¨å¯¼å…¥å®Œæˆ: å…± {imported_count} æ¡è®°å½•")
    
    def _parse_manual_input(self, line):
        """è§£ææ‰‹åŠ¨è¾“å…¥ï¼Œè¿”å› (point, value)"""
        parts = [p.strip() for p in line.split(',')]
        values = []
        for p in parts:
            try:
                values.append(float(p))
            except ValueError:
                raise ValueError(f"'{p}' ä¸æ˜¯æœ‰æ•ˆæ•°å­—")
        n_params = len(self.config.param_bounds)
        if len(values) < n_params + 1:
            raise ValueError(f"éœ€è¦è‡³å°‘ {n_params+1} ä¸ªå€¼")
        point = np.array(values[:n_params])
        for i, (val, bounds) in enumerate(zip(point, self.config.param_bounds)):
            if val < bounds[0] or val > bounds[1]:
                param_name = self.config.param_names[i]
                raise ValueError(f"å‚æ•° '{param_name}' å€¼ {val} è¶…å‡ºèŒƒå›´ [{bounds[0]}, {bounds[1]}]")
        value = values[n_params]
        return point, value
    
    def _import_single_record(self, record, orch):
        """å°†ä¸€æ¡è®°å½•æ·»åŠ åˆ° Orchestrator çš„å†å²ä¸­"""
        point = np.array(record.get('point', []))
        if len(point) != len(self.config.param_bounds):
            return
        value = record.get('value', 0)
        entry = HistoryEntry(
            point=point,
            value=value,
            algorithm=record.get('algorithm_used', 'historical'),
            timestamp=record.get('timestamp', time.time())
        )
        orch.history.append(entry)
    
    def _get_search_directories(self):
        """æ–‡ä»¶æœç´¢ç›®å½•"""
        search_dirs = [
            os.getcwd(),
            os.path.expanduser("~"),
            os.path.expanduser("~/Downloads"),
            os.path.expanduser("~/Documents"),
            os.path.expanduser("~/Desktop"),
        ]
        android_paths = [
            "/storage/emulated/0",
            "/storage/emulated/0/Download",
            "/storage/emulated/0/Documents",
            "/sdcard",
            "/sdcard/Download",
            "/sdcard/Documents",
        ]
        search_dirs.extend(android_paths)
        if 'EXTERNAL_STORAGE' in os.environ:
            search_dirs.append(os.environ['EXTERNAL_STORAGE'])
        unique_dirs = []
        seen = set()
        for d in search_dirs:
            if d not in seen and os.path.isdir(d):
                unique_dirs.append(d)
                seen.add(d)
        return unique_dirs
    
    def _find_file(self, filename, extensions=None):
        """æ™ºèƒ½æ–‡ä»¶æŸ¥æ‰¾"""
        import os
        if os.path.isabs(filename) and os.path.isfile(filename):
            return filename
        if os.path.isfile(filename):
            return os.path.abspath(filename)
        search_dirs = self._get_search_directories()
        for directory in search_dirs:
            full_path = os.path.join(directory, filename)
            if os.path.isfile(full_path):
                return full_path
            if extensions:
                for ext in extensions:
                    if filename.endswith(ext):
                        continue
                    full_path_with_ext = os.path.join(directory, filename + ext)
                    if os.path.isfile(full_path_with_ext):
                        return full_path_with_ext
        return None
    
    def _show_search_paths(self, filename):
        """æ˜¾ç¤ºæœç´¢è·¯å¾„"""
        import os
        search_dirs = self._get_search_directories()
        print("
å·²å°è¯•ä»¥ä¸‹ä½ç½®:")
        for i, directory in enumerate(search_dirs[:10], 1):
            full_path = os.path.join(directory, filename)
            print(f"  {i}. {full_path}")
        if len(search_dirs) > 10:
            print(f"  ... ä»¥åŠå…¶ä»– {len(search_dirs) - 10} ä¸ªä½ç½®")
    
    def _export_results(self, orch):
        """è°ƒç”¨å¯¼å‡ºå™¨ç»„ä»¶"""
        exporters = registry.list_components('exporter')
        if not exporters:
            print("
âš ï¸ æ²¡æœ‰å¯ç”¨çš„å¯¼å‡ºå™¨")
            return
        print("
ğŸ“ å¯¼å‡ºç»“æœï¼š")
        for i, e in enumerate(exporters):
            print(f"  {i}. {e.name}")
        exp_idx = int(input("é€‰æ‹©å¯¼å‡ºæ ¼å¼ [ä¸å¯¼å‡º]: ") or "-1")
        if 0 <= exp_idx < len(exporters):
            exp_name = exporters[exp_idx].name
            exp_cls = registry.get_component(exp_name)
            exporter = exp_cls()
            algo_short = self.selected_algorithm or 'optimization'
            filepath = f"result_{algo_short}.{exp_name.split('.')[-1]}"
            if 'plot' in exp_name and not filepath.endswith(('.png', '.jpg', '.pdf')):
                filepath = filepath.rsplit('.', 1)[0] + '.png'
            exporter.export(orch.get_history(), filepath)
            print(f"âœ… å·²ä¿å­˜è‡³ {filepath}")