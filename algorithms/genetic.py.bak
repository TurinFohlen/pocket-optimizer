import numpy as np
from typing import List, Tuple
from registry import registry

# 距离服务单例
_svc = None
def _get_dist_svc():
    global _svc
    if _svc is None:
        svc_cls = registry.get_component('service.distance')
        _svc = svc_cls() if svc_cls else None
    return _svc

@registry.register(
    name='algorithm.genetic',
    type_='algorithm',
    signature='optimize(bounds: List[Tuple[float, float]]) -> Tuple[np.ndarray, float]'
)
class GeneticAlgorithm:
    def __init__(self, source):
        self.source = source
        self.population_size = 20
        self.generations = 15
        self.mutation_rate = 0.1
        self.crossover_rate = 0.8
        # 多样性惩罚参数
        self.diversity_threshold = 0.01   # 切比雪夫距离阈值（相对于最大范围）
        self.diversity_penalty_strength = 0.2  # 额外变异强度
    
    def optimize(self, bounds: List[Tuple[float, float]]) -> Tuple[np.ndarray, float]:
        n_dims = len(bounds)
        lower = np.array([b[0] for b in bounds])
        upper = np.array([b[1] for b in bounds])
        span = upper - lower
        threshold = self.diversity_threshold * np.max(span)
        
        # 初始化种群
        population = np.random.uniform(lower, upper, size=(self.population_size, n_dims))
        
        # 距离服务
        dist_svc = _get_dist_svc()
        if dist_svc:
            # 初始种群加入历史库（可选）
            dist_svc.add_points(population)
        
        best_point = None
        best_value = -np.inf
        
        for generation in range(self.generations):
            # ---------- 评估 ----------
            fitness = np.zeros(self.population_size)
            for i, ind in enumerate(population):
                value = self.source.measure(ind, n_samples=5)
                fitness[i] = value
                if dist_svc:
                    dist_svc.add_point(ind)
                if value > best_value:
                    best_value = value
                    best_point = ind.copy()
            
            # ---------- 选择概率 ----------
            fitness_norm = fitness - fitness.min() + 1e-10
            probs = fitness_norm / fitness_norm.sum()
            
            # ---------- 繁殖（交叉+变异）----------
            new_population = []
            for _ in range(self.population_size // 2):
                parent1 = population[np.random.choice(self.population_size, p=probs)]
                parent2 = population[np.random.choice(self.population_size, p=probs)]
                
                if np.random.rand() < self.crossover_rate:
                    pt = np.random.randint(1, n_dims)
                    child1 = np.concatenate([parent1[:pt], parent2[pt:]])
                    child2 = np.concatenate([parent2[:pt], parent1[pt:]])
                else:
                    child1, child2 = parent1.copy(), parent2.copy()
                
                for child in (child1, child2):
                    if np.random.rand() < self.mutation_rate:
                        idx = np.random.randint(n_dims)
                        child[idx] = np.random.uniform(lower[idx], upper[idx])
                    np.clip(child, lower, upper, out=child)
                
                new_population.extend([child1, child2])
            
            population = np.array(new_population[:self.population_size])
            
            # ---------- 批量多样性惩罚（切比雪夫距离）----------
            if dist_svc and dist_svc.size > 5:
                # 一次性查询整个种群的最小切比雪夫距离
                dists, _ = dist_svc.kneighbors(population, n_neighbors=1, metric='chebyshev')
                too_close = dists[:, 0] < threshold
                if np.any(too_close):
                    noise = np.random.normal(0, self.diversity_penalty_strength * span, size=population.shape)
                    population[too_close] += noise[too_close]
                    np.clip(population, lower, upper, out=population)
                    # 重新加入历史库（可选）
                    dist_svc.add_points(population[too_close])
        
        return best_point, best_value